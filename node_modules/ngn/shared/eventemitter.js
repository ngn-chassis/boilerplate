/**
  * v0.3.31 generated on: Thu May 18 2017 01:24:44 GMT+0000 (UTC)
  * Copyright (c) 2014-2017, Ecor Ventures LLC. All Rights Reserved. See LICENSE (BSD3).
  */
'use strict'

NGN.inherit(Object.defineProperties({}, {
  queued: NGN.private({}),
  collectionQueue: NGN.private({}),
  thresholdQueue: NGN.private({}),

  deprecate: NGN.const((deprecatedEventName, replacementEventName) => {
    const me = this

    this.on(deprecatedEventName, function () {
      console.warn(deprecatedEventName + ' is deprecated.' + (!replacementEventName ? '' : 'Use ' + replacementEventName + ' instead.'))

      if (replacementEventName) {
        let args = NGN.slice(arguments)
        args.shift()
        args.unshift(replacementEventName)

        me.emit.apply(me, args)
      }
    })
  }),

  pool: NGN.const(function (prefix, group, callback) {
    if (typeof prefix !== 'string') {
      group = prefix
      prefix = ''
    }

    let pool = {}

    for (let eventName in group) {
      let topic = (prefix.trim() || '') + eventName

      if (typeof group[eventName] === 'function') {
        this.setMaxListeners(this.getMaxListeners() + 1)
        pool[eventName] = this.on(topic, group[eventName])
      } else if (typeof group[eventName] === 'object') {
        this.pool(topic + '.', group[eventName])
      } else {
        console.warn('%c' + topic + '%c could not be pooled in the event emitter because it\'s value is not a function.', NGN.css, '')
      }
    }

    if (NGN.isFn(callback)) {
      callback(pool)
    }
  }),

  attach: NGN.const(function (eventName, preventDefaultAction) {
    preventDefaultAction = NGN.coalesce(preventDefaultAction, false)

    return (e) => {
      if (preventDefaultAction && typeof e.preventDefault === 'function') {
        e.preventDefault()
      }

      let args = NGN.slice(arguments)
      args.unshift(eventName)

      this.emit.apply(this, args)
    }
  }),

  forward: NGN.const(function (eventName, triggers, payload) {
    triggers = typeof triggers === 'string' ? [triggers] : triggers

    let me = this
    let listener = function () {
      let args = NGN.slice(arguments)

      if (payload) {
        args.push(payload)
      }

      for (let trigger in triggers) {
        let argList = args.slice()
        argList.unshift(triggers[trigger])
        me.emit.apply(me, argList)
      }
    }

    this.setMaxListeners(this.getMaxListeners() + 1)
    this.on(eventName, listener)

    return {
      remove: () => {
        this.setMaxListeners(this.getMaxListeners() - 1)
        this.off(eventName, listener)
      }
    }
  }),

  bind: NGN.privateconst(function () {
    return NGN.deprecate(this.forward, 'NGN.BUS.bind is now NGN.BUS.forward')(...arguments)
  }),

  delayEmit: NGN.const(function (eventName, delay) {
    if (!this.queued.hasOwnProperty(eventName)) {
      let args = NGN.slice(arguments)
      args.splice(1, 1)

      this.queued[eventName] = setTimeout(() => {
        delete this.queued[eventName]
        this.emit.apply(this, args)
      }, delay)
    }
  }),

  queue: NGN.privateconst(function () {
    return NGN.deprecate(this.delayEmit, 'NGN.BUS.queue is now NGN.BUS.delayEmit')(...arguments)
  }),

  funnel: NGN.const(function (eventCollection, triggerEventName, payload = null) {
    if (!Array.isArray(eventCollection)) {
      throw new Error('NGN.BUS.bindEvents expected an array of events, but received a(n) ' + typeof eventCollection)
    }

    eventCollection = NGN.dedupe(eventCollection)

    let me = this
    let key = this.getInternalCollectionId(this.collectionQueue)

    this.collectionQueue[key] = {}

    Object.defineProperties(this.collectionQueue[key], {
      masterqueue: NGN.const(eventCollection),
      remainingqueue: NGN.private(eventCollection),
      eventName: NGN.const(triggerEventName),
      remove: NGN.const(function () {
        let evts = me.collectionQueue[key].masterqueue.slice()

        delete me.collectionQueue[key]

        evts.forEach(function (evtName) {
          me.setMaxListeners(me.getMaxListeners() - 1)
          me.off(evtName, me.handleCollectionTrigger(evtName, key))
        })
      }),
      payload: NGN.const(payload)
    })

    eventCollection.forEach((evt) => {
      me.setMaxListeners(me.getMaxListeners() + 1)
      this.on(evt, this.handleCollectionTrigger(evt, key))
    })

    return this.collectionQueue[key]
  }),

  getInternalCollectionId: NGN.privateconst(function (collection) {
    let time = (new Date()).getTime().toString()
    let rand = Math.random().toString()
    let key = Object.keys(collection).length + 1

    while (collection.hasOwnProperty(key.toString() + time + rand)) {
      key++
    }

    return key.toString() + time + rand
  }),

  handleCollectionTrigger: NGN.privateconst(function (eventName, key) {
    let me = this
    return function () {
      setTimeout(() => {
        if (me.collectionQueue.hasOwnProperty(key)) {
          if (me.collectionQueue[key].remainingqueue.indexOf(eventName) >= 0) {
            me.collectionQueue[key].remainingqueue = me.collectionQueue[key].remainingqueue.filter((remainingEventName) => {
              return remainingEventName !== eventName
            })
          }

          if (me.collectionQueue[key].remainingqueue.length === 0) {
            me.collectionQueue[key].remainingqueue = me.collectionQueue[key].masterqueue

            if (NGN.isFn(me.collectionQueue[key].eventName)) {
              me.collectionQueue[key].eventName(me.collectionQueue[key].payload)
            } else {
              me.emit(me.collectionQueue[key].eventName, me.collectionQueue[key].payload)
            }
          }
        }
      }, 0)
    }
  }),

  funnelOnce: NGN.const(function (eventCollection, triggerEventName, payload = null) {
    let collection = this.funnel(eventCollection, triggerEventName, payload)

    this.setMaxListeners(this.getMaxListeners() + 1)
    this.once(triggerEventName, () => {
      collection.remove()
      collection = null
    })
  }),

  threshold: NGN.const(function (thresholdEventName, limit, finalEventName, payload = null) {
    if (typeof thresholdEventName !== 'string') {
      throw new Error('The threshold event name must be a string (received ' + (typeof thresholdEventName) + ')')
    }

    let me = this
    let key = this.getInternalCollectionId(this.thresholdQueue) + limit.toString()

    this.thresholdQueue[key] = {}

    Object.defineProperties(this.thresholdQueue[key], {
      key: NGN.const(key),
      eventName: NGN.const(thresholdEventName),
      limit: NGN.const(limit),
      count: NGN.private(0),
      finalEventName: NGN.const(finalEventName),
      remove: NGN.const(function () {
        let evt = me.thresholdQueue[key].eventName

        delete me.thresholdQueue[key]

        me.setMaxListeners(me.getMaxListeners() - 1)
        me.off(evt, me.handleThresholdTrigger(key))
      }),
      payload: NGN.const(payload)
    })

    this.setMaxListeners(this.getMaxListeners() + 1)
    this.on(thresholdEventName, this.handleThresholdTrigger(key))

    return this.thresholdQueue[key]
  }),

  thresholdOnce: NGN.const(function (thresholdEventName, limit, finalEventName, payload = null) {
    let threshold = this.threshold(thresholdEventName, limit, finalEventName, payload)

    this.once(finalEventName, () => {
      threshold.remove()
      threshold = null
    })
  }),

  handleThresholdTrigger: NGN.const(function (key) {
    let me = this
    return function () {
      setTimeout(() => {
        if (me.thresholdQueue.hasOwnProperty(key)) {
          me.thresholdQueue[key].count++
          if (me.thresholdQueue[key].count === me.thresholdQueue[key].limit) {
            if (NGN.isFn(me.thresholdQueue[key].finalEventName)) {
              me.thresholdQueue[key].finalEventName(me.thresholdQueue[key].payload)
            } else {
              me.emit(me.thresholdQueue[key].finalEventName, me.thresholdQueue[key].payload)
            }

            if (me.thresholdQueue.hasOwnProperty(key)) {
              me.thresholdQueue[key].count = 0
            }
          }
        }
      }, 0)
    }
  })
}), NGN.EventEmitter)
