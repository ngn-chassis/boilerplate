/**
  * v0.3.31 generated on: Thu May 18 2017 01:24:44 GMT+0000 (UTC)
  * Copyright (c) 2014-2017, Ecor Ventures LLC. All Rights Reserved. See LICENSE (BSD3).
  */
'use strict'

NGN.Tasks = function () {
  class TaskRunner extends NGN.EventEmitter {
    constructor (mode = 'production') {
      super()

      Object.defineProperties(this, {
        steps: NGN.private([]),
        completed: NGN.private(0),
        timeout: NGN.private(null),
        _mode: NGN.private(mode),
        _cancel: NGN.private(false),
        processing: NGN.private(false),
        timer: NGN.private(null),
        sequential: NGN.private(false)
      })

      this.on('taskcomplete', (step) => {
        if (this.sequential || step.status === 'completed') {
          return
        }

        step._status = 'complete'

        this.completed++

        if (this.mode === 'dev') {
          console.info(step.name + ' completed.')
        }

        if (this.completed === this.steps.length) {
          this.processing = false

          Object.keys(this.steps).forEach((step) => {
            clearTimeout(this.steps[step].timer)
          })

          this.emit('complete')
        }
      })

      this.on('aborting', () => {
        this._cancel = true
      })
    }

    get list () {
      return this.steps.map(function (s) {
        return {
          id: s.number,
          name: s.name,
          status: s.status
        }
      })
    }

    get mode () {
      return this._mode
    }

    set mode (value) {
      if (value.toLowerCase().substr(0, 3) === 'dev') {
        this._mode = 'dev'
      } else {
        this._mode = 'production'
      }
    }

    get cancelled () {
      return this._cancel
    }

    onTimeout () {
      let log = []

      if (this.steps.length > 0) {
        this.steps.forEach((s) => {
          log.push(s.name, s.status === null ? 'NOT STARTED' : s.status)
        })
      }

      this.emit('timeout', {
        process: log
      })

      log = null
    }

    add (name, fn) {
      if (this.processing) {
        return console.warn('Cannot add a step while processing.')
      }

      if (typeof name === 'function') {
        fn = name
        name = 'Step ' + (parseInt(this.steps.length) + 1)
      }

      if (typeof fn !== 'function') {
        throw new Error('No processing method defined for step ' + (parseInt(this.steps.length) + 1) + '.')
      }

      const me = this
      const queue = new NGN.Task({
        name: name,
        callback: fn,
        number: (this.steps.length > 0 ? this.steps[this.steps.length - 1].number : 0) + 1
      })

      queue.on('complete', (step) => this.emit('taskcomplete', step))

      queue.on('timeout', (step) => {
        if (step.status === 'running' || step.status === 'timedout') {
          this.emit('tasktimeout', step)
        }
      })

      this.steps.push(queue)
      this.emit('taskcreate', queue)
    }

    getAt (index) {
      return this.steps[index]
    }

    get (requestedStep) {
      let element = this.steps.filter((step) => {
        return step.name === requestedStep
      })

      if (element.length === 1) {
        return element[0]
      }

      element = this.steps.filter((step) => {
        return step.number === requestedStep
      })

      if (element.length === 1) {
        return element[0]
      }
    }

    remove (requestedStep) {
      if (this.processing) {
        return console.warn('Cannot add a step while processing.')
      }

      let element = this.steps.filter((step) => {
        return step.name === requestedStep
      })

      if (element.length === 1) {
        this.steps = this.steps.filter((step) => {
          return step.name !== requestedStep
        })

        this.emit('taskremove', element[0])
        return element[0]
      }

      element = this.steps.filter((step) => {
        return step.number === requestedStep
      })

      if (element.length === 1) {
        this.steps = this.steps.filter((step) => {
          return step.number !== requestedStep
        })

        this.emit('taskremove', element[0])
        return element[0]
      }
    }

    removeAt (requestedStep) {
      if (this.processing) {
        return console.warn('Cannot add a step while processing.')
      }

      if (typeof requestedStep !== 'number') {
        return console.error('Failed to remove step: ' + requestedStep)
      }

      if (requestedStep < 0 || requestedStep >= this.steps.length) {
        return console.error('Step index ' + requestedStep + ' could not be found or does not exist.')
      }

      return this.steps.splice(requestedStep, 1)[0]
    }

    reset () {
      if (this.processing) {
        return console.warn('Cannot reset a running queue. Abort or wait for the process to complete before resetting.')
      }

      this.steps.forEach((step) => {
        step._skip = false
      })
    }

    process (sequential) {
      if (this.processing) {
        return console.warn('Cannot start processing (already running). Please wait for this process to complete before calling process() again.')
      }

      if (this.steps.length === 0) {
        return this.emit('complete')
      }

      this.processing = true
      this._cancel = false

      if (this.timeout !== null) {
        this.timer = setTimeout(() => this.onTimeout(), this.timeout)
      }

      this.sequential = typeof sequential === 'boolean' ? sequential : false
      if (!this.sequential) {
        for (let i = 0; i < this.steps.length; i++) {
          this.steps[i].run(this.mode)
        }
      } else {
        let queue = this.steps
        let listener = new NGN.EventEmitter()

        listener.on('taskcomplete', () => {
          if (queue.length > 0) {
            const currentTask = queue.shift()

            if (currentTask.skipped) {
              return listener.emit('taskcomplete')
            }

            currentTask.on('complete', () => listener.emit('taskcomplete'))
            currentTask.on('start', () => this.emit('taskstart', currentTask))

            currentTask.run(this.mode)
          } else {
            this.emit('complete')
          }
        })

        let currentStep = queue.shift()

        currentStep.on('complete', () => listener.emit('taskcomplete'))
        currentStep.on('start', () => this.emit('taskstart', currentStep))

        currentStep.run(this.mode)
      }
    }

    run () {
      this.process(...arguments)
    }

    abort () {
      this.emit('aborting')

      this.each((step) => {
        if (['completed', 'running', 'timedout'].indexOf(step.status) < 0 && !step.skipped) {
          step.skip()
        }
      })

      this.once('complete', () => this.emit('aborted'))
    }

    each (fn) {
      for (let i = 0; i < this.steps.length; i++) {
        fn(this.steps[i])
      }
    }

    cancel () {
      this.abort(...arguments)
    }
  }

  return TaskRunner
}

NGN.Tasks = NGN.Tasks()

if (NGN.nodelike) {
  module.exports = NGN.Tasks
}
