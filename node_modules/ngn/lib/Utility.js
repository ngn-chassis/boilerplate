/**
  * v0.3.31 generated on: Thu May 18 2017 01:24:44 GMT+0000 (UTC)
  * Copyright (c) 2014-2017, Ecor Ventures LLC. All Rights Reserved. See LICENSE (BSD3).
  */
'use strict'

const net = require('net')
const fs = require('fs')
const os = require('os')
const crypto = require('crypto')

module.exports = {
  createTunnel: function (options, callback) {
    let me = this
    let tunnel
    let sshcfg = {
      host: this.host + ':' + (options.sshport || 22),
      user: options.username,
      remoteport: this.port
    }

    if (options.password) {
      sshcfg.password = options.password
    }

    if (options.key) {
      sshcfg.key = options.key
    }

    if (options.port) {
      sshcfg.port = options.port
      tunnel = new NGN.Tunnel(sshcfg)
      tunnel.on('ready', function () {
        NGN.BUS.emit('sshtunnel.create', tunnel)
        callback && callback(me.host, options.port)
      })
      tunnel.connect()
    } else {
      let tmp = net.createServer().listen(0, '127.0.0.1', function () {
        sshcfg.port = this.address().port
        tmp.close()
      })

      tmp.on('close', function () {
        tunnel = new NGN.Tunnel(sshcfg)
        tunnel.on('ready', function () {
          callback && callback('127.0.0.1', sshcfg.port)
        })
        tunnel.connect()
      })
    }
  },

  pathExists: function (dir) {
    try {
      fs.accessSync(dir)
      return true
    } catch (e) {
      return false
    }
  },

  pathReadable: function (dir) {
    try {
      fs.accessSync(dir, fs.R_OK)
      return true
    } catch (e) {
      return false
    }
  },

  pathWritable: function (dir) {
    try {
      fs.accessSync(dir, fs.W_OK)
      return true
    } catch (e) {
      return false
    }
  },

  fileExecutable: function (dir) {
    if (os.platform() === 'win32') {
      throw new Error('NGN.util.fileExecutable() is not available on Windows')
    }
    try {
      fs.accessSync(dir, fs.X_OK)
      return true
    } catch (e) {
      return false
    }
  },

  checksum (content, algorithm, encoding) {
    return crypto
      .createHash(algorithm || 'md5')
      .update(content, 'utf8')
      .digest(encoding || 'hex')
  }
}
