/**
  * v0.3.31 generated on: Thu May 18 2017 01:24:44 GMT+0000 (UTC)
  * Copyright (c) 2014-2017, Ecor Ventures LLC. All Rights Reserved. See LICENSE (BSD3).
  */
'use strict'

const rpc = require('ngn-rpc')
const util = require('../Utility')

class Client extends NGN.EventEmitter {

  constructor (config) {
    config = config || {}

    super()

    let _req = rpc.axon.socket('req')
    Object.defineProperties(this, {
      host: NGN.const(config.host || 'localhost'),

      port: NGN.const(parseInt(config.port, 10)),

      autoConnect: NGN.public(NGN.coalesce(config.autoConnect, true)),

      ssh: NGN.privateconst(config.ssh || {}),

      _methods: NGN.private([]),
      _connecting: NGN.private(false),
      _initialized: NGN.private(false),
      req: NGN.private(_req),
      _client: NGN.private(new rpc.Client(_req)),
      id: NGN.private((new Date()).getTime())
    })

    const me = this
    this.req.on('disconnect', function () {
      me._connecting = false
      me.emit('disconnect', me.id)
    })

    this.req.on('reconnect attempt', function () {
      me._connecting = true
      me.emit('reconnecting', me.id)
    })

    this.req.on('error', function (err) {
      me.emit('error', err)
    })

    let ignored = 0
    this.req.on('ignored error', function (err) {
      if (err.code === 'ECONNREFUSED') {
        ignored = ignored + 1
        if ((ignored % 20 === 0 || ignored === 1) && ignored < 100) {
          console.warn('Socket connection to ' + err.address + ':' + err.port + ' failed. Attempting to reconnect from client ' + me.id + '.')
        }
      }
    })

    this.req.on('close', function () {
      me._connecting = false
      me.emit('disconnect', me.id)
    })

    this.req.on('connect', function () {
      me._connecting = false

      if (me._initialized) {
        return me.emit('reconnected', me.id)
      }

      me.getRemoteMethods(function () {
        me.emit('ready', me.id)
      })
    })

    this.on('connecting', function () {
      me._connecting = true
    })

    this.on('ready', function () {
      me._initialized = true
    })

    if (this.autoConnect) {
      this.connect()
    }
  }

  get connected () {
    return this.req.connected
  }

  get connecting () {
    return this._connecting
  }

  getRemoteMethods (callback) {
    const me = this

    this._client.methods(function (err, cmethods) {
      if (err) throw err
      if (Object.keys(cmethods).length === 0) {
        console.warn('The RPC service has no available methods.')
      } else {
        Object.keys(cmethods).forEach(function (mthd) {
          if (!me.hasOwnProperty(mthd)) {
            Object.defineProperty(me, mthd, {
              enumerable: true,
              writable: false,
              configurable: false,
              value: me.getMethodTree(cmethods[mthd], mthd)
            })
            me._methods.push(mthd)
          } else {
            console.warn('Client already has method ' + mthd + '. Skipping.')
          }
        })
      }
      if (callback) {
        callback()
      }
    })
  }

  connect () {
    if (this.connected) {
      console.warn('Client is already connected!')
      return
    }

    if (this.connecting) {
      return
    }

    this._connecting = true

    this.emit('connecting')

    let me = this
    if (this.ssh.user) {
      util.createTunnel(this.ssh, function (host, port) {
        me.req.connect(host, port)
      })
    } else {
      this.req.connect(this.port, this.host)
    }
  }

  get remotemethods () {
    return this._methods
  }

  disconnect () {
    if (!this.connected) {
      console.warn('Client is not connected!')
      return
    }

    this._client.disconnect()
  }

  getMethodTree (obj, scope) {
    const me = this

    scope = Array.isArray(scope) === true ? scope : (typeof scope === 'string' ? [scope] : [])

    if (obj.hasOwnProperty('name') && obj.hasOwnProperty('params')) {
      return function () {
        let args = Array.prototype.slice.call(arguments)
        let _fn = typeof args[args.length - 1] === 'function' ? args.pop() : function () {}
        let _mthd = scope.slice(0)

        _mthd = _mthd.join('.')

        me._client.call.apply(me._client, [_mthd].splice(0).concat(args).concat([ function () {
          _fn.apply(_fn, Array.prototype.slice.call(arguments))
        }]))
      }
    } else {
      var _obj = {}
      for (let attr in obj) {
        if (obj.hasOwnProperty(attr)) {
          let _scope = scope.slice(0)
          _scope.push(attr)
          _obj[attr] = me.getMethodTree(obj[attr], _scope.join('.'))
        }
      }
      return _obj
    }
  }
}
module.exports = Client
