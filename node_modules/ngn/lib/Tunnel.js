/**
  * v0.3.31 generated on: Thu May 18 2017 01:24:44 GMT+0000 (UTC)
  * Copyright (c) 2014-2017, Ecor Ventures LLC. All Rights Reserved. See LICENSE (BSD3).
  */
'use strict'

const SSH2 = require('ssh2').Client
const fs = require('fs')
const path = require('path')

class Tunnel extends NGN.EventEmitter {
  constructor (config, callback) {
    super()

    config = config || {}
    config.host = config.host || '127.0.0.1:22' 
    config.user = config.user || null
    config.password = config.password || null
    config.key = config.key || null
    config.port = config.port || null 
    config.remoteport = config.remoteport || null 

    let me = this
    let ready = false
    let sshport = 22

    if (config.host.split(':').length > 1) {
      sshport = config.host.split(':')[1]
    }

    let sshconn = {
      host: config.host.split(':')[0],
      port: sshport
    }

    if (config.user !== null) {
      sshconn.username = config.user
    }

    if (config.password !== null) {
      sshconn.password = config.password
    }

    if (config.key) {
      let p = path.resolve(config.key)
      if (fs.existsSync(p)) {
        sshconn.privateKey = fs.readFileSync(p).toString()
      } else if (fs.existsSync(path.join(__dirname, p))) {
        sshconn.privateKey = fs.readFileSync(path.join(__dirname, p)).toString()
      } else {
        sshconn.privateKey = config.key
      }
    }

    let tunnel = new SSH2()

    let proxy = require('net').createServer(function (sock) {
      if (!ready) {
        return sock.destroy()
      }

      sock.setNoDelay()

      tunnel.forwardOut(sock.remoteAddress, sock.remotePort, sshconn.host, config.remoteport, function (err, stream) {
        if (err) {
          if (err.reason && err.message) {
            console.warn(err.message, err.reason)
          }
          return sock.destroy()
        }
        stream.setNoDelay()
        sock.pipe(stream)
        stream.pipe(sock)
      })
    })

    proxy.on('close', function () {
      ready = false
      me.emit('close')
    })

    proxy.on('listening', function () {
      tunnel.connect(sshconn)
    })

    tunnel.on('ready', function () {
      ready = true

      config.callback && config.callback()

      callback && callback()

      me.emit('ready')
    })

    tunnel.on('error', function (err) {
      if (err.code === 'ENOTFOUND') {
        me.emit('error', new Error('host unreachable'))
      } else {
        me.emit('error', err)
      }

      me.close()
    })

    tunnel.on('end', function () {
      ready = false
      proxy.close()
    })

    tunnel.on('connect', function () {
      me.emit('connected')
    })

    this.connect = function () {
      proxy.listen(config.port, '127.0.0.1')
    }

    this.disconnect = function () {
      tunnel.end()

      if (!tunnel._sock.readable) {
        tunnel.emit('end')
      }
    }
  }

  close () {
    this.disconnect()
  }

  get connected () {
    return NGN.coalesce(this.ready, false)
  }
}

module.exports = Tunnel
