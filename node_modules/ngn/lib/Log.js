/**
  * v0.3.31 generated on: Thu May 18 2017 01:24:44 GMT+0000 (UTC)
  * Copyright (c) 2014-2017, Ecor Ventures LLC. All Rights Reserved. See LICENSE (BSD3).
  */
'use strict'

class Log extends NGN.EventEmitter {
  constructor () {
    super()

    const self = this

    let methods = [
      'log',
      'info',
      'error',
      'warn',
      'time',
      'timeEnd',
      'trace',
      'assert',
      'dir',
      'debug',
      'io'
    ]

    methods.forEach(function (event) {
      self.on(event, function () {
        const output = Array.from(arguments)
        const args = ['logevent', {
          name: event,
          content: output.length === 1 ? output[0] : output
        }]
        self.emit.apply(self, args)
      })
    })

    global.LoggingMethodError = NGN.createException({
      name: 'Logging Method Error',
      type: 'LogMethodError',
      message: 'The logging method does not exist or could not be found.',
      custom: {
        cause: 'An NGN.Log attribute was defined that was not a function.',
        help: 'This can usually be fixed by making sure the value assigned to an NGN.Log.___ is a function. Acceptable methods include: ' + methods.join()
      }
    })

    global.DuplicateLoggingMethodError = NGN.createException({
      name: 'Duplicate Logging Method Error',
      type: 'LogMethodError',
      message: 'An attempt to redefine an existing logging method failed.',
      custom: {
        cause: 'An attempt to define/redefine a custom method on NGN.Log conflicts with an existing method.',
        help: 'This is usually the result of trying to redefine a custom method or overriding an existing native method (' + methods.join() + ').'
      }
    })

    methods.forEach(function (method) {
      Object.defineProperty(self, '_' + method, NGN.private(null))

      Object.defineProperty(self, method, {
        enumerable: true,
        get: function () {
          return this['_' + method]
        },
        set: function (val) {
          if (typeof val !== 'function') {
            throw new LoggingMethodError(method + ' does not exist or could not be found.')
          }
          this['_' + method] = val
        }
      })
    })

    Object.defineProperties(this, {
      stream: NGN.public('all'),

      _level: NGN.private('all'),
      level_cache: NGN.private({}),

      useColor: NGN.public(true),

      _enabled: NGN.private(true),

      middleware: NGN.private({})
    })


    Object.defineProperties(console, {
      current_level: NGN.private(null),
      level: NGN.const(function (lvl) {
        this.current_level = lvl || null
        return this
      })
    })

    let _console = {}
    let debugconsole = {}

    methods.forEach(function (method) {
      debugconsole[method] = function () {}

      _console[method] = console[console.hasOwnProperty(method) ? method : 'log']

      console[method] = function () {
        if (!self.enabled) {
          _console[method].apply(null, arguments)
          return
        }

        let args = Array.from(arguments)

        let currLevel = ''
        if (console.current_level !== null) {
          currLevel = console.current_level
          args.unshift({
            _level_: console.current_level
          })
          console.current_level = null
        }

        if (!self.shouldProcess(currLevel || '')) {
          return
        }

        if (self.hasOwnProperty(method)) {
          if (self[method] !== null) {
            let cont = self[method].apply(self, args)
            if (!cont) {
              return
            }
          }
        }

        if (self.middleware[method]) {
          self.middleware[method].forEach(function (fn) {
            args = fn(args)
          })
        }

        let argList = args
        argList.unshift(method)

        self.emit.apply(self, argList)

        self.LanEnabled && debugconsole[method].apply(this, args)

        if (self.useColor) {
          for (let arg in args) {
            if (['error', 'warn', 'debug', 'info'].indexOf(method) >= 0) {
              let supported = false
              switch (typeof args[arg]) {
                case 'boolean':
                case 'number':
                case 'date': 
                  args[arg] = args[arg].toString()
                case 'string': 
                  supported = true
                  break
              }
              if (supported) {
                switch (method) {
                  case 'error':
                    args[arg] = args[arg].red.bold
                    break
                  case 'warn':
                    args[arg] = args[arg].yellow.bold
                    break
                  case 'info':
                    args[arg] = args[arg].cyan.bold
                    break
                  case 'debug':
                    args[arg] = args[arg].magenta.bold
                    break
                }
              }
            }
          }
        }

        if (['io'].indexOf(method.toLowerCase()) < 0) {
          _console[method].apply(console, args)
        } else if (method === 'io') {
          process.stdout.write('Flow: '.blue + args[0].blue.bold + '\n')
          if (args[1]) {
            process.stdout.write(args[1].toString().blue.bold + '\n')
          }
        }
      }
    })

    console.write = function () {
      NGN.Log.write.call(null, arguments[0])
    }
  }

  get LanEnabled () {
    if (typeof this.stream === 'string') {
      return ['none', ''].indexOf(this.stream.trim().toLowerCase()) < 0
    } else if (NGN.typeOf(this.stream) === 'array') {
      return this.stream.length > 0
    } else if (typeof this.stream === 'boolean') {
      return this.stream
    }
    return true
  }

  get level () {
    return this._level
  }

  set level (val) {
    this.level_cache.hasOwnProperty(val) && delete this.level_cache[val]
    this._level = val
  }

  get enabled () {
    return this._enabled
  }

  set enabled (val) {
    this._enabled = val
    this.emit(val ? 'enabled' : 'disabled')
  }

  enable () {
    this.enabled = true
  }

  disable () {
    this.enabled = false
  }

  shouldProcess (level) {
    if (typeof level !== 'string') {
      throw new Error('NGN.Log#shouldProcess() requires a string attribute.')
    }
    level = (level.trim().length === 0 ? 'none' : level).trim().toLowerCase()
    if (!this.level_cache.hasOwnProperty(level)) {
      if (this.level === 'all') {
        this.level_cache[level] = true
      } else if (typeof this.level === 'string') {
        if (['none', ''].indexOf(level) >= 0) {
          this.level_cache[level] = false
        }
        this.level_cache[level] = (this.level.trim().toLowerCase() === level)
      } else if (NGN.typeof(this.level) === 'array') {
        this.level_cache[level] = this.level.filter(function (el) {
          return el.trim().toLowerCase() === level.trim().toLowerCase()
        }).length >= 1
      } else if (typeof this.level === 'boolean') {
        this.level_cache[level] = this.level
      }
      this.level_cache[level] = true
    }
    return this.level_cache[level]
  }

  createMethod (name, callback) {
    if (this.hasOwnProperty(name)) {
      throw new DuplicateLoggingMethodError('The method "' + name + '" cannot be redefined. This method already exists.')
    }

    const self = this
    let fn = function () {
      let args = Array.prototype.slice.call(arguments)
      self.emit(name, args)
      self.emit('logevent', {
        name: name,
        data: args || null
      })
      if (callback) {
        callback.apply(self, arguments)
      }
    }

    console[name] = fn
  }

  write () {
    const args = Array.from(arguments)

    args.forEach(function (content) {
      content = typeof content === 'object' ? JSON.stringify(content, null, 2) : content
      try {
        content = content.toString()
      } catch (e) {}
      if (typeof content === 'string') {
        process.stdout.write(content.trim() + '\n')
      } else {
        process.stdout.write('Could not convert output to a string.\n')
      }
    })
  }

  use (method, fn) {
    this.middleware[method] = this.middleware[method] || []
    this.middleware[method].push(fn)
  }

  unuse (method, fn) {
    if (this.middleware[method]) {
      if (!isNaN(fn)) {
        this.middleware.splice(fn, 1)
        return
      }

      let success = false
      let me = this
      this.middleware[method].forEach(function (mw, i) {
        if (mw.toString() === fn.toString()) {
          success = true
          me.middleware[method].splice(i, 1)
        }
      })

      if (success) {
        if (this.middleware[method].length === 0) {
          delete this.middleware[method]
        }
        return
      }
      process.stdout.write('The specified logging middleware function for ' + method + ' was not found.')
    } else {
      process.stdout.write('Logging middleware for ' + method + ' not found.')
    }
  }
}

module.exports = Log
