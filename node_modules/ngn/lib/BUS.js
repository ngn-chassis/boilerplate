/**
  * v0.3.31 generated on: Thu May 18 2017 01:24:44 GMT+0000 (UTC)
  * Copyright (c) 2014-2017, Ecor Ventures LLC. All Rights Reserved. See LICENSE (BSD3).
  */
'use strict'

const RpcClient = require('./rpc/Client')
const HealthCheck = require('./Health')
const EventSource = require('eventsource')
const util = require('./Utility')
const URL = require('url')

class BUS extends NGN.EventEmitter {
  constructor () {
    super()

    Object.defineProperties(this, {
      _host: NGN.private('localhost:5555'),
      remote: NGN.private(null),
      options: NGN.private(null),
      _paused: NGN.private(false),
      remotebus: NGN.private(new NGN.EventEmitter()),
      _remotebus: NGN.private(null),
      _remoteshipping: NGN.private(false),
      healthmonitor: NGN.privateconst(new HealthCheck()),
      healthwarning: NGN.private(false),
      _queue: NGN.private({}),
      triggers: NGN.private([
        'connecting',
        'connect',
        'disconnect',
        'pause',
        'resume',
        'healthmonitor.enabled',
        'healthmonitor.disabled'
      ])
    })

  }

  get host () {
    return this._host.split(':')[0]
  }

  get port () {
    let parts = this._host.split(':')
    return parts.length === 1 ? 5555 : parseInt(parts[1], 10)
  }

  get connected () {
    return NGN.coalesce(this.remote && this.remote.connected, false)
  }

  get connecting () {
    return NGN.coalesce(this.remote && this.remote.connecting, false)
  }

  get paused () {
    return this._paused
  }

  connect (rhost, options) {
    const me = this

    if (arguments.length === 0) {
      if (typeof NGN._meta.bridge === 'object') {
        rhost = NGN._meta.bridge.host || 'localhost:5555'
        options = {}
        Object.keys(NGN._meta.bridge).forEach(function (key) {
          options[key] = NGN._meta.bridge[key]
        })
      }
    }

    this._host = rhost || this._host
    options = options || {}

    if (Object.keys(options) > 0) {
      this.options = options
    }

    if (options.username) {
      util.createTunnel(options, function (host, port) {
        me.createConnection(host, port)
      })
    } else {
      this.createConnection(this.host, this.port)
    }
  }

  createConnection (host, port) {
    const me = this

    if (this.remote === null) {
      NGN._bridge = NGN._bridge || new RpcClient({
        host: host,
        port: port
      })
      this.remote = NGN._bridge

      this.remote.on('ready', function () {
        me.createRemoteChannel(function (success) {
          if (!success) {
            console.log('Could not establish a connection with the remote BUS.')
          }
          me.enableLogShipping()
          me.enableRemoteHealthReports()
          me.healthmonitor.start()
          me.emit('ready')
        })
        me.emit('connect')
      })

      this.remote.on('connecting', function () {
        me.emit('connecting')
      })

      this.remote.on('disconnect', function () {
        me.disableLogShipping()
        me.disableRemoteHealthReports()
        NGN._bridge = null
        me.emit('disconnect')
      })
    }

    this.remote.connect()
  }

  pause () {
    this._paused = true
    this.emit('pause')
  }

  resume () {
    this._paused = false
    this.emit('resume')
  }

  disconnect () {
    const me = this
    this.healthwarning = false
    this.once('healthmonitor.disabled', function () {
      me.healthmonitor.stop()
      if (me._remotebus !== null && me._remotebus.close) {
        me._remotebus.close()
      }
      if (me.remote && me.remote.disconnect) {
        me.remote.disconnect()
      }
    })
    this.disableRemoteHealthReports()
  }

  createRemoteChannel (callback) {
    const me = this
    if (this.connected && this.remote.subscribe) {
      this.remote.subscribe(function (err, out) {
        if (err) {
          throw err
        }
        if (out.path && out.port) {
          let url = URL.format({
            protocol: out.protocol || 'http',
            hostname: me.remote.host,
            port: out.port,
            pathname: out.path
          })

          let headers = {}

          if (out.token) {
            headers.Authentication = 'token ' + out.token
          }

          let channel = new EventSource(url, {
            rejectUnauthorized: false,
            headers: headers
          })

          me._remotebus = channel

          channel.onmessage = function (e) {
            me.emit(e.content)
          }

          channel.onerror = function (e) {
            me.emit('error', e)
          }

          channel.on('close', function () {
            me._remotebus = null
          })

          Object.keys(me._events).forEach(function (topic) {
            if (me.triggers.indexOf(topic) < 0) {
              channel.addEventListener(topic, me.bubble(topic))
            }
          })

          me.on('newListener', function (topic) {
            if (me.triggers.indexOf(topic) < 0) {
              channel.addEventListener(topic, me.bubble(topic))
            }
          })

          if (callback) {
            callback(true)
          }
        } else if (callback) {
          callback(false)
        }
      })
    } else if (callback) {
      callback(false)
    }
  }

  bubble (topic) {
    const me = this
    return function (e) {
      me.emit(topic, e.content || null)
    }
  }

  broadcast () {
    if (arguments.length === 0) {
      return
    }

    const args = Array.from(arguments)
    if (this.remote.send) {
      args.push(function () {})
      this.remote.send.apply(this, args)
      args.pop()
    } else {
      console.warn('Broadcast failed. No remote "send" method/connection available.')
    }
    this.emit.apply(this, args)
  }

  forwardHealth (topic) {
    const me = this
    return function (data) {
      if (!me.connected) {
        if (!me.healthwarning) {
          console.warn('Cannot send ' + topic + 'data to remote server (not connected).')
          me.healthwarning = true
        }
        return
      }
      me.broadcast(topic, data || null)
    }
  }

  shipRemoteLog () {
    const me = this
    return function (event) {
      me.broadcast('syslog.' + event.name.replace(/[^A-Za-z0-9]/gi, ''), event.content || null)
    }
  }

  enableLogShipping () {
    if (NGN.Log && NGN.Log.on) {
      NGN.Log.on('logevent', this.shipRemoteLog())
    }
  }

  disableLogShipping () {
    if (console.removeListener) {
      console.removeListener('logevent', this.shipRemoteLog)
    }
  }

  enableRemoteHealthReports () {
    this.switchRemoteHealthReports()
    this.emit('healthmonitor.enabled')
  }

  disableRemoteHealthReports () {
    this.switchRemoteHealthReports('off')
    this.emit('healthmonitor.disabled')
  }

  switchRemoteHealthReports (evt) {
    evt = evt || 'on'
    this.healthmonitor[evt]('health.info', this.forwardHealth('health.info'))
    this.healthmonitor[evt]('health.status', this.forwardHealth('health.status'))
    this.healthmonitor[evt]('health.heartbeat', this.forwardHealth('health.heartbeat'))
    this.healthmonitor[evt]('health.error.rejection', this.forwardHealth('health.error.rejection'))
    this.healthmonitor[evt]('health.error.uncaught', this.forwardHealth('health.error.uncaught'))
  }

  ssh (options) {}
}

module.exports = new BUS()
